_model: page
---
title: Basics
---
order: 2
---
article:

### Overview

Bolt derives all functionality via plugins. Bolt provides a super-class for plugins to use which
handles a lot of the boilerplate for them. We want to get out of the way and allow plugin authors
to get down to business of just writing the code they need.

-----

#### Basic Example

```python
from bolt import Plugin
from bolt import command

class Example(Plugin):

    @command("hello")
    def ping(self, message):
        self.say(message.channel_id, "world!")
```

#### Example explained
* We created a plugin named "Example"
* Example defines a single command
* That command will be invoked anytime someone says "!hello" (The bot trigger is a configurable option)
* The handler will then post a message to the channel the message originally came from saying "world!"


-----

### Plugin Loading / Unloading

Plugins will automatically call a method named `activate` when they are loaded. Think of this like
the `__init__` function.

```python
from bolt import Plugin

class Example(Plugin):
    def activate(self):
        # do startup stuff
```

The reason we don't expose init itself is that we need to load the object instance, and need to be
sure it runs things from the super-init function so we can uniformly expose a clean API to plugin
authors.


Plugins are loaded dynamically, and are namespaced from one another. It should not be possible to
load the same plugin twice, or overwrite another plugin.


-----

### Plugin API

The plugin API exposes a number of convenient ways to programming the bot.


1. Commands - Simple way of defining how a command will be invoked from Discord
2. Webhooks - Data sent to the bot via HTTP endpoint
3. Interval - Handler executed on a set time interval
4. Schedule - Schedule code to run at a later time
5. Events - Respond to events from Discord
6. Database - Save state into a MongoDB database
7. Posting to Discord
    1. Saying something in a channel
    2. Sending a user a private message
8. Logging
