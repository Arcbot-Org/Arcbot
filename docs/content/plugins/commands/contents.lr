_model: page
---
title: Commands
---
order: 1
---
article:

### Basic Commands
```python
from bolt import Plugin
from bolt import command

class SayHi(Plugin):
    @command("hi")
    def hi(self, event):
        self.say(event.channel.id, f"Hello {event.sender.name}")
```

This will register a command with the bot's plugin manager.

If someone says "hi" in a text channel that the bot is in; then the decorated function will execute.
Commands themselves don't remember state, unless persisted to the database or set state on the
plugin class itself. It is recommended that you use the database for most stateful things.

------

### Regex Commands

```python
from bolt import Plugin
from bolt import regex_command

class SayHi(Plugin):
    @regex_command("^hi( there)?$")
    def hi(self, event):
        self.say(event.channel.id, f"Hello {event.sender.name}")
```

Regex commands take (you guessed it) a regular expression as a definition. These are incredibly
efficient to use because the command parser does regex compilation. They are also very expressive,
but do tend to get messy quickly.

Refer to [Python's builtin regex parsing](https://docs.python.org/3/library/re.html) for more
information.

------

### Parse Commands

```python
from bolt import Plugin
from bolt import parse_command

class SayHi(Plugin):
    @parse_command("hi {yourname}")
    def hi(self, event):
        args = event.arguments
        self.say(event.channel.id, f"Hello {event.sender.name}, you called me {args['yourname']}")
```

This works by leveraging the [Parse library](https://pypi.org/project/parse/). Its just another way
you can be more expressive with how you define commands. This is very useful for things that require
positional params in commands but don't need complicated regular expressions.

`event.arguments` will return the args and kwargs that were parsed by the command parser. You can
refer to those values as in the example.
